//                          LENDO UMA MATRICULA !!! (http://localhost:3000/pessoas/1/matricula/5)

[00:00] Nossa aplicação já está fazendo CRUD para Pessoas, Níveis e Turmas. Ou seja, conseguimos criar pessoas novas, puxar todos os níveis, alterar uma turma, etc. Por que não fizemos a mesma coisa com matrículas, então?

[00:11] Vamos pensar em como nosso sistema está organizado. Faz sentido uma rota onde eu posso vir, no Postman, em níveis, com o método post e criar um novo nível, por exemplo: ‘descr_nivel’, e eu crio um novo nível, digamos assim, conversação básica: ‘descr_nivel’: “conversação básica”. Seleciono POST e crio um novo nível.

[00:38] Ele criou. Faz sentido existir esse end-point para criarmos novos níveis. Agora, quando falamos de Matrículas, um tipo de dado de matrícula só faz sentido se tivermos associado as matrículas a um estudante em especial. Esse end-point, /matrículas: http://localhost:3000/matriculas/, solto, sem estar relacionado a nenhuma pessoa, não faz muito sentido para o sistema.

[01:04] Para deixar organizado, faz mais sentido para o front-end receber um end-point onde ele passa, de repente, o ID da pessoa, e aí ou ver todas as matrículas dela, ou deletar uma matrícula, ou alterar uma matrícula de um ID x, do que receber dessa forma sem estar relacionada a nenhum usuário do sistema.

[01:28] E é por isso que faremos o CRUD de matrícula assim, faremos alguns métodos agora, mas não criaremos para Matrículas um controlador próprio e uma rota própria. Faremos isso dentro do controlador de Pessoas. Ou seja, as matrículas vão estar vinculadas a sempre uma pessoa, um aluno.

[01:47] Vamos ao banco dar uma olhada em como estão nossos registros de matrícula nesse momento lá no banco. Então, darei um select * from Matrículas;.

[02:02] Então, no meu banco, o de vocês pode estar um pouco diferente dependendo das alterações que vocês foram fazendo nos testes. O estudante de ID 1 tem três registros, duas matrículas confirmadas em turmas diferentes e uma matrícula cancelada. Esses IDs da primeira coluna são os IDs das matrículas, de como elas entraram no banco e estão relacionadas à tabela Pessoas através da coluna estudante_id.

[02:24] Então, vamos dizer que eu quero trazer a matrícula 5, a matrícula cancelada, do estudante 1. Como que ficaria então dentro do controlador de Pessoas? O método é bem parecido com os outros que já usamos em Pessoas. Criamos um método para trazer um registro só, o método pegaUmaPessoa, que usa findOne do Sequelize para ir até o banco e trazer só um registro.

[02:53] Então, vamos copiar para aproveitarmos esse método e vermos como fazemos para funcionar com Matrículas. Então, ao invés de pegaUmaPessoa, será pegaUmaMatricula.

[03:04] Recebe requisição e resposta igual, mas que informações preciso passar para o Sequelize para ele trazer o dado certo? Vamos voltar no Postman. No http, eu dei uma simulada. Deixa eu voltar. Eu quero, por exemplo, pegar a matrícula de ID 5 que está relacionada a uma pessoa de ID 1: http://localhost:3000/pessoas/1/matricula/5. Vamos copiar esse http e colocar no nosso código para ele ajudar a nos guiar.

[03:31] Deixa eu colar ele. Então, no final, como é essa rota? Ela funciona da seguinte maneira, em http://localhost:3000/pessoas/1/matricula/5, 1 era o que estávamos passando como ID para Pessoas. Se viermos em “api> routes> pessoasRoute.js”, passamos o parâmetro pessoas/id, pessoas/1, que é o ID da tabela Pessoas. Ele acha no banco.

[04:02] Então, em http://localhost:3000/pessoas/1/matricula/5, 1 é o ID da pessoa e 5 seria o ID da matrícula. http://localhost:3000/pessoas/:id/matricula/:matriculaId. Podemos trocar o :id por estudanteId: http://localhost:3000/pessoas/:estudanteId/matricula/:matriculaId, para ficar claro do que estamos falando.

[04:23] Então, a rota vai ser essa http://localhost:3000/pessoas/:estudanteId/matricula/:matriculaId. Entraremos em pessoas, passaremos um ID de pessoa que existe no banco, para ir em matrícula e passar um ID de matrícula.

[04:33] Quando formos acessar, acessaremos usando os números que já estão no banco. Então, os IDs que pegaremos através dos parâmetros da requisição, lembrando que parâmetros de requisição são aqueles acompanhados pelos dois pontos, serão estudanteId e matriculaId: const { estudanteId, matriculaId } = req.params.

[04:57] Então o Sequelize irá até os parâmetros da requisição, encontrará os dois parâmetros e guardar em const. E aí, como faremos agora dentro do try-catch? Ao invés de umaPessoa, será umaMatricula, e a database, se formos lembrar, é onde damos require nos modelos, em models/index.js, então ele está acessando todos os modelos que estão na pasta. Não queremos o modelo Pessoas, e sim acessar o modelo Matrículas.

[05:34] Porque olha a tabela que estamos nos conectando, é a tabela matrículas. findOne encontra um, o método é esse mesmo. Onde, ID = número de ID. O que é esse ID? Essa propriedade do objeto onde estamos passando o where é o nome da coluna. Então, o que é a coluna ID? É a matrícula ID, que é cinco, no caso:

[06:06] A outra coluna que queremos que o Sequelize bata as informações é estudante_id estudanteId agora é a variável que está guardando a informação que trouxemos dos parâmetros da requisição http, 5, 1, etc.

[06:42] Fez isso, foi ao banco, consultou, trouxe, salvou dentro da variável da constante uma matrícula. Vamos pedir para o Sequelize retornar em json os dados de uma matrícula, certo? Então o método está feito, só precisamos agora ir ao nosso arquivo de rotas e criar essa rota, porque ainda não existe, então vamos lá.

[07:07] Será em pessoasRoute.js “api> routes> pessoasRoute.js”, Matrículas não terá as próprias rotas. Então, router.get(‘/pessoas/:estudanteId/matricula/:matriculaId’, PessoaController.pegaUmaMatricula) o primeiro parâmetro é uma string com a rota que queremos passar, e o segundo parâmetro é o método que queremos que ele chame quando bater na rota: PessoaController e pegaUmaMatricula.

[07:32] É esse mesmo o nome do nosso método? Vamos ver se é isso, pegaUmaMatricula, exatamente esse mesmo. Ok? Agora, podemos ir no Postman e testar com o endereço http://localhost:3000/pessoas/1/matricula/5, só que com get. Então, vamos testar essa rota, ver se ele vai pegar a matrícula 5.

[07:49] Pegou a matrícula 5. Então, o que fizemos? Agora, a nossa aplicação não está fazendo só CRUD separado, cada um na sua tabela. Ela consegue fazer em tabelas que estão relacionadas. Consigo ir ao controlador de Pessoas, relacionar Pessoas com Matrículas e trazer as informações correspondentes.

//                         CRIANDO UMA MATRICULA !!! (http://localhost:3000/pessoas/1/matricula)

[00:00] Então vamos criar mais um método do CRUD? Vamos ver como ficaria para criarmos uma matrícula nova? Também temos no nosso controlador de Pessoas como criar uma pessoa. Vamos aproveitar ele também. Vou dar um copy, ir até o final criar um novo método. Então vai ser criaMatricula(), também lembrando que as matrículas estão relacionadas a um ID de pessoa, sempre.

[00:30] Então o que temos que passar para criar uma matrícula nova? Vamos ao Postman. Eu vou tirar o ID do http, porque se é uma nova matrícula que eu vou postar, ela não tem ID: http://localhost:3000/pessoas/1/matricula. Então eu quero criar uma nova matrícula para pessoa de ID 1.

[00:46] Além de passar o ID da pessoa, eu tenho que passar também uma informação no corpo da minha requisição. No body, eu tenho que passar a informação da matrícula que eu quero criar. Então o Sequelize vai precisar de duas informações: a primeira é receber o ID: const { id } = req.params. Trocarei o id para estudanteId para não ter confusão, para sabermos o que estamos falando. E também precisa de informação sobre a nova matrícula que será criada, informação do corpo da requisição.

[01:35] Então, a nossa const const novaMatricula = { ... req.body } receberá o quê? Faremos um spread das informações que virão no corpo da requisição, ou seja, o que é o corpo da requisição? Lembrando quando criamos Pessoas? São as informações que passamos no formato json através do Postman. Então passaremos. Opa, vamos fazer um spread, quase esqueci dos três pontos do spread antes de req.body.

[02:04] Então faremos um spread com o corpo da requisição e o número de ID do nosso estudante: `const novaMatricula = { ...req.body, estudante_id: Number(estudanteId) }. Mesma coisa do outro.

[02:29] Então no objeto vai ter o ID de estudante, onde queremos inserir o dado de matrícula novo e mais as informações que passaremos no corpo da requisição. O nosso try-catch terá uma const novaMatriculaCriada, consultaremos a database de matrículas, não de Pessoas. O método é create mesmo, para criar um novo registro no banco, e usaremos com o parâmetro do create, as informações que o create precisa para criar esse novo registro no banco, o que geramos e foi guardado dentro da const novaMatricula.

[03:12] E o nosso retorno, para o nosso usuário saber que deu tudo certo, ou não, passaremos no formato json as informações que acabamos de criar, o retorno do método create. O retorno do método create será guardado na const novaMatriculaCriada e será exibido no formato json.

[03:32] Lembrando que, antes de testarmos no Postman, temos que criar a rota: router.post(‘/pessoas/:estudanteId/matricula’, PessoaController.criaMatricula).

[04:05] Agora podemos testar. Do que precisamos para testar? Ir até o Postman, método post, vamos criar uma nova matrícula para estudante 1? O que precisamos passar? As informações que ele espera receber, estudante_id, status e turma_id.

[04:26] Se passarmos status e turma_id. Então, de repente, vamos confirmar na turma 2. Status e turma ID. Por que não precisamos passar estudante_id? Porque estudante_id já será pego através dos parâmetros e já vai compor com o spread no nosso objeto, estudante_id já está sendo passado e não precisamos passar.

[04:52] Precisamos passar no body status, que vou passar “confirmado”, e turma_id, que será a turma 4. Então, vamos testar com o post, se está tudo certo. Ok.

[05:11] Criou no estudante_id: 1, que passamos, na turma 4, status confirmado. Vamos ao banco? Então vamos selecionar select: select * from Matriculas.

[05:29] Então vou dar um select Matrículas. Ele criou uma nova matrícula com ID 8, estudante 1, na turma 4. Então, a partir de agora, já conseguimos criar todo o CRUD que precisamos de matrículas. E nossa aplicação está fazendo sentido, trazendo todas as informações que precisamos e midpoints que fazem sentido para o nosso sistema, para nossa aplicação.


//                                ATUALIZANDO E DELETANDO !!!

[00:00] Para completarmos o CRUD das matrículas, falta atualizar uma matrícula e deletar uma matrícula. Vamos subir nos métodos, achar o método atualizaPessoa(), e ver se conseguimos aproveitar o que já escrevemos nele para criar o atualizaMatricula().

[00:17] Então, vou copiar o atualizaPessoa(), mandar para baixo e vamos ver o que fizemos nele. Trocaremos atualizaPessoa() por atualizaMatricula(). Lembrando que, no caso das matrículas, atualizaremos uma matrícula específica, então precisamos do id da pessoa, do id do aluno específico e do id da matrícula específica que queremos atualizar.

[00:42] Fizemos isso no método pegaUmaMatricula(), criamos essa const para receber nos parâmetros da requisição o id de aluno, o id de estudante e o id de matrícula. Então podemos usar a mesma novamente, estudanteId, matriculaId. Vamos receber ambos os valores através dos parâmetros da requisição, e também precisaremos de novas infos. É aquele objeto com as informações que vamos atualizar e que serão passadas no corpo da requisição, no formato json, da mesma forma que fizemos anteriormente, ok.

[01:19] O que foi feito no try do método update quando usamos em pessoas? await será database.Matriculas, porque consultaremos o modelo Matrículas. O método update do Sequelize é o mesmo, recebe dois parâmetros: o primeiro também é o mesmo, novasInfos, que são as informações que ele enviará para o banco para atualizar, e o segundo são os parâmetros do registro que ele quer atualizar.

[01:46] Lembrando que, no where, teremos que passar duas propriedades, estudanteId e matriculaId. Lembrando que o Id que está na propriedade é a coluna. Como estamos falando do modelo Matrícula, id: Number(matriculaId), e o segundo que temos que passar é a coluna estudante_id: estudante_id: Number(estudanteId).

[02:27] Só lembrando porque criamos a const pessoaAtualizada e foi ao banco de novo com ofindOne encontrar o registro (vou trocar pessoaAtualizada por MatriculaAtualizada): o método update do Sequelize não retorna um json com as informações atualizadas, ele retorna somente 0 ou 1, fez ou não fez.

[02:52] Então para podermos passar para o nosso usuário um json com as informações, precisamos voltar na database, no caso, no modelo Matrículas, mesmo método findOne, e pediremos para só trazer a matrícula atualizada que tem o número de matriculaId. Está sendo feita primeiro a parte de fazer update, e posteriormente, o Sequelize volta no banco, consulta o ID que foi atualizado, e na linha 99 retornamos para o nosso usuário o json com as informações atualizadas.

[03:34] Vamos então inserir uma rota correspondente para esse método. Deixa eu ver o que já fizemos. Bom, temos uma rota, router.post, não, router.get, que usa o mesmo endpoint: router.get(‘pessoas/:estudanteId/matricula/:matriculaId’, PessoaController.pegaUmaMatricula), que nem colocamos de modelo no Postman: http://localhost:3000/pessoas/1/matricula/5.

[03:57] Então vamos copiar esse método da linha 11 para ficar mais rápido. router.get(‘pessoas/:estudanteId/matricula/:matriculaId’, PessoaController.pegaUmaMatricula). Nesse caso, o método não será get, e sim put, para atualizarmos. O endpoint é o mesmo e o método da classe PessoaController será atualizaMatricula, router.put(‘pessoas/:estudanteId/matricula/:matriculaId’, PessoaController.atualizaMatricula).

[04:17] Podemos testar. Vamos ver como é que está no banco. No banco, a matrícula 5 do estudante 1 um está como confirmada. Vamos mudar para cancelada então, para testarmos. No corpo da requisição, abriremos o objeto e só precisamos mandar a informação que desejamos alterar, que no caso é o status cancelado.

[04:48] Vamos dar o “Sent”. Não é get, eu vivo fazendo esse erro. Tem que mudar para put. Os dados que queremos alterar estão todos digitados: matrícula 5, do id 1, dá o post. E ok, ele nos retornou, o status agora está cancelado, as informações estão atualizadas. Podemos inclusive voltar no terminal do MySQL e dar um select * from Matriculas.

[05:12] E agora o 5 está cancelado. Última coisa a fazer aqui é o método delete, pedir para deletar a matrícula. Então vamos ver o que fizemos para deletar Pessoas. Podemos apagar alguns comentários que eu deixei das aulas passadas. Vamos copiar o método apagaPessoa, levá-lo para baixo, colar e substituir por apagaMatricula.

[05:50] Do que precisamos para apagar matrícula? Das mesmas informações que precisamos para atualizar uma matrícula: precisamos do estudante_id e matricula_id. Podemos copiar e colar const { estudanteId, matriculaId } = req.params, porque precisamos das mesmas informações para apagarmos matrícula específica do estudante específico.

[06:09] No try, o que está acontecendo: está consultando os modelos através da variável database. Nesse momento, consultaremos o modelo database.Matriculas, e usar o método destroy do Sequelize, e a informação é muito importante, se você não passa aqui qual que você deseja destruir, ele pode destruir todas as matrículas do seu banco. Esse where é super importante. Ele só vai destruir o registro onde bater o número de ID.

[0:31] Lembrando que é o ID de matrícula, então é matriculaId. E não temos o que retornar como json porque o registro foi destruído, então não temos como retornar informações, estamos retornando para o nosso usuário apenas uma mensagem dizendo que o ID (matriculaId) foi deletado. E aí você pode também personalizar, colocar a mensagem que achar que é mais pertinente.

[07:07] Vamos criar uma rota em “api> routes> pessoasRoute.js”. O endpoint é (‘pessoas/:estudanteId/matricula/:matriculaId’, PessoaController.pegaUmaMatricula), o método http será delete, e na classe PessoaController, chamaremos apagaMatricula: router.delete(‘pessoas/:estudanteId/matricula/:matriculaId’, PessoaController.apagaMatricula).

[07:27] Vamos apagar outra matrícula, vamos ao terminal do mySQL. Vamos, de repente, apagar a 6. Então, ID 6 do estudante 2, só para trabalharmos com registro diferente, porque estávamos usando sempre o mesmo. Então, usaremos delete, antes que eu esqueça de trocar o put. O http ficará: http://localhost:3000/pessoas/2/matricula/6. Apertamos o send e vamos ver se aparece a mensagem.

[07:53] Ok, ID 6 deletado. Está tudo funcionando. Agora a nossa API. Vamos voltar às tabelas. Agora todas as operações dessas tabelas estão funcionando e nossa API já tem informações, dados, para ser montado, por exemplo, o front do nosso sistema da escola de inglês.