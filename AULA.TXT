//Por enquanto, nosso projeto está dessa forma: criamos o nosso primeiro modelo, “Pessoas”.

// Mas, o modelo “Pessoas” não está conectado ainda ao resto da aplicação. Está conectado ao banco, sim, mas a parte da aplicação que a testamos no Postman está toda aqui: nosso usuário está fazendo uma requisição para /teste; na parte da aplicação, onde está definida a rota-teste, já está inclusive resolvendo essa rota-teste, devolvendo um pequeno objeto com uma mensagem de boas-vindas; que o usuário está vendo no Postman, no formato .json.

// Como fazemos, então, para ligar o modelo ao restante da aplicação? O modelo é uma parte muito importante do sistema. É nele que estão as regras de negócio, ele que se conecta com o banco, então não é bom deixarmos a parte de modelo acessível para toda a aplicação, para ficar mexendo livremente nessa parte.

// Então, veja que o “modelo” do MVC nós já temos, e a “vista” também. Falta o C, que é o controlador, “Controller” que entra justamente entre o modelo e as rotas/vista, para fazer esse intermédio, esse meio de campo, entre o modelo, que não queremos que seja muito acessível, digamos assim, e o restante da aplicação.

// Suponha que queremos acessar o modelo Pessoas e que nosso usuário veja um .json com todas as pessoas que estão cadastradas. Através de uma requisição HTTP, que nosso usuário faz, ele pode fazer uma requisição, por exemplo, para uma rota /pessoas. Essa rota aqui fala: bom, é uma rota /pessoas, então eu vou chamar o controlador de Pessoas.

// Cada modelo da nossa aplicação tem o seu próprio controlador, e escreveremos tudo isso aos poucos para entendermos o que está acontecendo. O controlador, a parte “Modelo e Controlador”, inclusive, do diagrama, fica separada do resto. Só o controlador que está passando dados para o modelo, e informa, modelo, estou precisando receber todos os dados de pessoas.

// O modelo vai enviar esses dados para o controlador de volta; o controlador vai resolver e passar para camada de “vista”, view, que vai gerar o .json, que nosso usuário vai receber no Postman.

// “Usuário”, eu coloquei usuário final/front, e coloquei HTML/JSON, porque normalmente, quando vemos esses diagramas, a parte de usuário pode se referir tanto a um quanto ao outro. Pode se referir tanto ao usuário final, que vai receber um HTML ou algo na tela dele; quanto ao front-end, que vai receber os dados no formato .json, normalmente, e vai usar esses dados na parte da frente da aplicação.

// Até aqui, o Sequelize fez bastante coisa, mas essa parte de controlador não tem comando. Ele não fez, então temos que fazer direto no código. Vou acessar “api> nova pasta” e chamar essa nova pasta de “controllers”, que é o nome padrão. Dentro de “controllers”, vou criar um arquivo que chama “PessoaController.js”. O “p” de Pessoa está em maiúsculo não é por acaso, é porque PessoaController será uma classe.


//                          INTERESSANTE!!:


//  Então, vamos criar a classe PessoaController, abre e fecha chaves, classe não recebe parâmetro, então não vamos precisar da função Construtora. O que a precisaremos é, dentro da classe, criar os métodos que usaremos. Como que eu sei quais são esses métodos? O que estou fazendo? Vamos dar uma relembrada.

// Então, vamos ao banco puxar nossa tabelinha de pessoas que eu já deixei aberta no terminal do SQL. Mas se você quiser abrir: select* from Pessoas;, selecionar tudo da tabela Pessoas.

// Então, temos as quatro operações principais, são as que mais fazemos quando estamos desenvolvendo APIs como estamos fazendo nesse projeto, que é o CRUD. Então, criamos novos registros, lemos, read, os registros que já estão no banco, atualizamos, update os recursos e deletamos recursos. Faremos essas quatro operações básicas e começaremos por ler o que já tem no banco. Primeiro lemos o que tem no banco, depois cria coisas novas, depois atualiza...

// Então, vamos criar um método que vai ler o que está aqui no banco, se conectar com o banco, ler o que está acontecendo, pegar todos os registros e nos mostrar no formato .json para podermos abrir no Postman. Então, o nosso método vai se chamar pegaTodasAsPessoas (req, res), que vai pegar todas as pessoas que estão no banco. Os parâmetros que esse método vai receber são: requisição e resposta, porque estamos trabalhando com requisições HTTP. Abre e fecha parênteses, abre e fecha chaves, desculpa.

// Antes de começarmos a escrever o que tem dentro desse método, vamos colocar duas palavras-chave: a primeira é static. Estou declarando com ela que esse método ele pode ser chamado no código, então posso chamá-lo sem ter que criar uma nova instância de classe, sem ter que criar um new PessoaController. Veremos isso um pouco mais para frente, quando começarmos a chamar esses métodos. Não precisamos criar uma PessoaController, salvar isso em uma constante. Para isso, usamos a palavra-chave static.

// A outra palavra-chave que usaremos é async, uma das palavras-chave do par async/await, que diz que esse método precisa esperar resolver alguns outros métodos internos que usaremos aqui dentro para então devolver a resposta. Faz parte da questão de sincronia e assincronia do JavaScript. Então vamos lá?

// Vamos criar uma nova const, que será chamada de const todasAsPessoas = await, e dentro dela eu vou guardar o resultado do que buscaremos no banco. Então, aqui, eu vou pedir para o JavaScript esperar ir até o banco, pegar as coisas e voltar, então ele vai dar um await, a palavra-chave que faz par com async.

// O que eu faço? Eu tenho que ir à database e, dentro dela, o JavaScript vai procurar por pessoas, pelo método que está em “api> migrations> pessoas.js”, onde estamos retornando pessoas.

// Então, eu vou em database, que já chamamos no início do código, dentro de database ele vai procurar Pessoas, e só prestando atenção, não é o nome do arquivo, e sim a const que está sendo retornada, estamos puxando através de database. Por isso que tem sempre que prestar atenção, porque palavras com letra maiúscula e minúscula fazem diferença.

// E o que vem aqui? Vamos usar um método do Sequelize, chamado “encontrar tudo”, findAll. Não vai levar nenhum parâmetro porque está encontrando tudo, não precisamos, nesse momento, dar nenhum parâmetro.

// Então, o que está acontecendo? Esse controlador vai consultar a tabela de pessoas e trazer o resultado. E aí que entra o Sequelize em ação, porque a query que seria selectAll, cadê meu terminal? A * query* que seria select * from pessoas e que poderíamos colocar no formato SQL dentro do código mesmo, foi substituída por um método escrito em JavaScript, que é esse método findAll do Sequelize.

// Ele que é responsável por fazer as queries necessárias no banco e tudo o que temos que fazer é tratar o resultado da requisição e passá-la para frente. Então, vamos testar ver, se está funcionando. E, para isso, vamos precisar de uma rota, porque para puxarmos, precisaremos ir ao Postman e falar “vai na rota tal e chama esse método”

//Antes de fazermos isso, vamos retornar, que estamos só criando a const e se não pedimos para retornar as coisas, ele não vai retornar.

// Então, faremos duas coisas, na verdade, para deixarmos esse método um pouco mais bonito: vamos retornar return res.status(200). json (todasAsPessoas), a resposta da requisição. Nessa resposta, vamos mandar um status code, de 200, que é o ok, o .json, formato que vimos no começo e que queremos inserir agora, e todasAsPessoas, porque ainda não está convertida para o .json, formato em que queremos receber, ainda precisa passar, ser convertida, e aí ser retornada.:

class PessoaController {
    static async pegaTodasAsPessoas(req, res) {
        const todasAsPessoas = await database.Pessoas.findAll()
        return res.status(200).json(todasAsPessoas)
    }
}

------------------------------------------------------------------------------------------------------------------------------------------

// Então, agora o método já está aqui, já tem o que retornar. Antes só de testarmos, vamos envolver tudo isso aqui por um try-catch, para deixarmos esse código mais organizado e para o JavaScript poder avisar se tiver algum tipo de erro. Então, no try, colocamos. Eu vou dar um “Ctrl + X”, recortar as linhas de código do const e do return, e eu vou colar dentro do try.

// Depois do try, temos o catch error. O que acontece quando tem algum erro: retornamos a um status de erro, vamos retornar 500, que é um erro de parte do servidor. E aí vou pedir para ele converter esse erro para o formato .json, mostrando, nesse .json, a mensagem de erro.

// Então, o que está acontecendo? Eu fiz um try-catch para caso dê algum erro, aconteça alguma coisa, o JavaScript ser capaz de pegar um erro no ar e nos mostrar esse erro no formato .json no próprio Postman, onde faremos nossos testes de rota:

class PessoaController {
    static async pegaTodasAsPessoas(req, res) {
        try {
            const todasAsPessoas = await database.Pessoas.findAll()
            return res.status(200).json(todasAsPessoas)
        } catch (error) {
            return res.status(200).json(error.message)
        }
    }
}

// A última coisa que temos que fazer, antes que eu esqueça, é exportar tudo isso. Então, module.exports = PessoaController, para poder ficar disponível para ser utilizado no restante do código. Então, agora é testar e ver se deu tudo certo.

------------------------------------------------------------------------------------------------------------------------------------------

//                      DICA:

Dependendo da necessidade ou da complexidade do projeto, é possível adicionar mais camadas à sua aplicação, além das que o MVC contempla (modelo - visão - controlador). Por exemplo, se vários controladores utilizam métodos semelhantes para as operações de banco, é possível abstrair estes métodos para uma camada própria, para que sejam utilizados pelos controladores.

Exemplos de camadas extras são: middlewares para autenticação de usuários e a chamada camada de serviços, que pode ser implementada para separar os métodos de acesso aos modelos, não sendo nesse caso o modelo acessado diretamente pelo controlador.

Lembrando sempre que, quanto mais separadas as responsabilidades, mais organizado fica o sistema. Nem sempre é preciso separar a aplicação em camadas extras, mas você pode fazer isso se perceber que alguma das camadas está fazendo mais do que a tarefa para a qual foi criada.